#!/usr/bin/env python3
import argparse
import concurrent.futures
import copy
import logging
import operator
import os
import socket
import subprocess
import sys
import time
import rosgraph
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta
from logging.handlers import RotatingFileHandler

import argcomplete
import paramiko
import yaml
from colorama import Fore

class CustomFormatter(logging.Formatter):
    """Logging Formatter to add colors and count warning / errors"""

    green = Fore.GREEN
    yellow = Fore.YELLOW
    red = Fore.RED
    bold_red = Fore.RED
    cyan = Fore.CYAN
    reset = Fore.RESET
    form = "[%(levelname)s] [%(asctime)s]: %(message)s"

    FORMATS = {
        logging.DEBUG: green + form + reset,
        logging.INFO: form,
        logging.WARNING: yellow + form + reset,
        logging.ERROR: red + form + reset,
        logging.CRITICAL: bold_red + form + reset,
    }

    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt)
        return formatter.format(record)


logging.addLevelName(logging.DEBUG, "D")
logging.addLevelName(logging.INFO, "I")
logging.addLevelName(logging.WARNING, "W")
logging.addLevelName(logging.ERROR, "E")
logging.addLevelName(logging.CRITICAL, "C")

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

custom_format = CustomFormatter()

streamHandler = logging.StreamHandler(sys.stdout)
streamHandler.setFormatter(custom_format)
logger.addHandler(streamHandler)

logPath = "/var/log"
if not os.access(logPath, os.W_OK):
    logPath = os.path.expanduser('~/log')
if not os.path.exists(logPath):
    os.makedirs(logPath)
logFile = "robmuxinator"
fileHandler = RotatingFileHandler(
    "{0}/{1}.log".format(logPath, logFile), maxBytes=1024*10000, backupCount=4)
format = logging.Formatter( "[%(levelname)s] [%(asctime)s]: %(message)s")
fileHandler.setFormatter(format)
logger.addHandler(fileHandler)

USE_PARAMIKO = False

DEFAULT_USER = "robot"
DEFAULT_HOST = socket.gethostname()
DEFAULT_PORT = None  # default port None disables port check


class SSHClient:
    """Handle commands over ssh tunnel"""

    def __init__(self, user, host):
        self._user = user
        self._host = host

        # check if user has sudo privileges
        self._sudo_user = True if os.getuid() == 0 else False

        # TODO: handle exceptions
        self.ssh_cli = None

    def init_connection(self):
        if self.ssh_cli is None:
            # set ssh key location for authentication
            if self._user == "root" and self._sudo_user:
                key_filepath = "/{}/.ssh/id_rsa".format(self._user)
            elif self._sudo_user:
                key_filepath = "/u/{}/.ssh/id_rsa".format(self._user)
            else:
                key_filepath = None

            try:
                self.ssh_cli = paramiko.client.SSHClient()
                self.ssh_cli.load_system_host_keys()
                self.ssh_cli.connect(   username=self._user, 
                                        hostname=self._host, 
                                        key_filename=key_filepath)
            except (paramiko.ssh_exception.SSHException, paramiko.ssh_exception.NoValidConnectionsError) as e:
                logger.error("  SSH Error: {}".format(e))
                raise e

    def send_cmd(self, cmd, wait_for_exit_status=True, get_pty=False):
        if USE_PARAMIKO:
            return self.send_cmd_paramiko(cmd, wait_for_exit_status, get_pty)
        else:
            return self.send_cmd_ssh(cmd, wait_for_exit_status, get_pty)

    def send_cmd_paramiko(self, cmd, wait_for_exit_status=True, get_pty=False):
        start = datetime.now()
        try:
            self.init_connection()
            _, stdout, stderr = self.ssh_cli.exec_command(cmd, get_pty=get_pty)
            returncode = 0
            if wait_for_exit_status:
                returncode = stdout.channel.recv_exit_status()
            logger.debug("send_cmd: {}  took {} secs".format(
                cmd, (datetime.now()-start).total_seconds()))
            return returncode, stdout, stderr
        except Exception as e:
            logger.error("{}".format(e))
            return 1, None, None

    def send_cmd_ssh(self, cmd, wait_for_exit_status=True, get_pty=False):
        start = datetime.now()
        cmd = "ssh {}@{} \"{}\"".format(self._user, self._host, cmd)
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        # TODO: check usage of stdout and stderr
        stdout, stderr = process.communicate()
        logger.debug("send_cmd: {}  took {} secs".format(
            cmd, (datetime.now()-start).total_seconds()))
        return process.returncode, stdout, stderr

    def send_keys(self, session_name, keys):
        cmd = "tmux send-keys -t {} '{}' ENTER".format(session_name, keys)
        returncode, stdout, stderr = self.send_cmd(cmd)
        return not returncode

    def has_session(self, session_name):
        cmd = 'tmux has-session -t {}'.format(session_name)
        returncode, stdout, stderr = self.send_cmd(cmd)
        return not returncode

    def new_session(self, session_name):
        cmd = 'tmux new -d -s {}'.format(session_name)
        returncode, stdout, stderr = self.send_cmd(cmd)
        return not returncode

    def kill_session(self, session_name):
        cmd = 'tmux kill-session -t {}'.format(session_name)
        returncode, stdout, stderr = self.send_cmd(cmd)
        return not returncode

    def stop_session(self, session_name):
        # get pid
        cmd = r'tmux list-panes -s -F \"#{pane_pid}\" -t ' + session_name
        returncode, stdout, stderr = self.send_cmd(cmd)
        pid = None
        if not returncode:
            if USE_PARAMIKO:
                pid = stdout.readlines()
                pid = pid[0].rstrip("\n") if len(pid) > 0 else None
            else:
                pid = stdout  # .readlines()
                pid = pid.decode().rstrip("\n") if len(pid) > 0 else None
            if pid:
                cmd = "pgrep -P {}".format(pid)
                returncode, stdout, stderr = self.send_cmd(cmd)
                if USE_PARAMIKO:
                    pid = stdout.readlines()
                    pid = pid[0].rstrip("\n") if len(pid) > 0 else None
                else:
                    pid = stdout
                    pid = pid.decode().rstrip("\n") if len(pid) > 0 else None
        else:
            print(
                Fore.RED + "  session {}: could not get pid for process".format(session_name))

        cmd = "tmux send -t {} C-c".format(session_name)

        returncode, stdout, stderr = self.send_cmd(cmd)

        if pid:
            cmd = "ps -p {} > /dev/null".format(pid)
            logger.info("  session {}: waiting 30 sec for process with pid {} to stop".format(
                session_name, pid))
            end = datetime.now() + timedelta(seconds=30)
            while datetime.now() < end:
                returncode, stdout, stderr = self.send_cmd(cmd)
                if returncode:
                    break
                time.sleep(0.25)
        self.kill_session(session_name)


# use a configurable timeout for hosts if ping succeeded.
class Host(object):
    """Base class for hosts"""

    def __init__(self, hostname, user):
        self._hostname = hostname
        self._user = user

    def get_hostname(self):
        return self._hostname

    def shutdown(self, timeout=30):
        pass

    def is_up(self):
        cmd = "ping -c 1 {} > /dev/null".format(self._hostname)
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        # TODO: check usage of stdout and stderr
        _, _ = process.communicate()
        return not process.returncode

    def wait_for_host(self, timeout=30):
        pass


class LinuxHost(Host):
    """Handle linux hosts"""

    def __init__(self, hostname, user, port=DEFAULT_PORT, check_nfs=True):
        super().__init__(hostname, user)
        self._ssh_client = SSHClient(user, hostname)
        self._port = port
        self._check_nfs = check_nfs

    def shutdown(self, timeout=60):
        logger.info("  shutting down {}...".format(self._hostname))
        cmd = "nohup sh -c '( ( sudo shutdown now -P 0 > /dev/null 2>&1 ) & )'"
        ret, _, _ = self._ssh_client.send_cmd(cmd, get_pty=True)

        if ret == 0:
            end = datetime.now() + timedelta(seconds=timeout)
            while self.is_up():
                time.sleep(0.25)
                if datetime.now() > end:
                    logger.error(
                        "  could not shutdown '{}' within {} secs".format(
                            self._hostname, timeout)
                    )
                    return False
        else:
            logger.error(
                "  could not exec shutdown command on '{}'".format(
                    self._hostname)
            )
            return False

        logger.info("  {} is down".format(self._hostname))
        return True

    def check_nfs_mount(self):
        cmd = "netstat | grep :nfs | grep {}".format(self._hostname)
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        _, _ = process.communicate()
        return not process.returncode

    def wait_for_host(self, timeout=30):
        logger.info("  waiting for {}...".format(self._hostname))
        end = datetime.now() + timedelta(seconds=timeout)
        while not self.is_up():
            time.sleep(0.25)
            if datetime.now() > end:
                logger.error(
                    "  could not ping '{}' within {} secs".format(
                        self._hostname, timeout)
                )
                return False
        if self._port:
            while True:
                try:
                    socket.create_connection(
                        (self._hostname, self._port), timeout=1)
                    break
                except OSError as ex:
                    logger.debug(
                        "  could not connect to '{}:{}' within {} secs: {}".format(
                            self._hostname, self._port, timeout, ex)
                    )
                time.sleep(0.25)
                if datetime.now() > end:
                    logger.error(
                        "  could not connect to '{}:{}' within {} secs".format(
                            self._hostname, self._port, timeout)
                    )
                    return False

        if self._check_nfs:
            while not self.check_nfs_mount():
                time.sleep(0.25)
                if datetime.now() > end:
                    logger.error(
                        "  could not find nfs mount for '{}' within {} secs".format(
                            self._hostname, timeout)
                    )
                    return False

        logger.info("  {} is up".format(self._hostname))
        return True


# TODO: windows hosts could also use port connection checks instead of simple pings
# if no ports for windows hosts are defined, use ping.
class WindowsHost(Host):
    """Handle windows hosts"""

    def __init__(self, hostname, user, port=DEFAULT_PORT):
        super().__init__(hostname, user)
        self._port = port

    def shutdown(self, timeout=60):
        logger.info("  shutting down {}...".format(self._hostname))
        cmd = 'net rpc shutdown -f -t 1 -I {host} -U rpc_user%rpc_user'.format(
            host=self._hostname
        )
        process = subprocess.Popen(
            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        # TODO: check usage of stdout and stderr
        _, _ = process.communicate()
        if not process.returncode:
            end = datetime.now() + timedelta(seconds=timeout)
            while self.is_up():
                time.sleep(0.25)
                if datetime.now() > end:
                    logger.error(
                        "  could not shutdown '{}' within {} secs".format(
                            self._hostname, timeout)
                    )
                    return False
        else:
            logger.error(
                "  could not exec shutdown command on '{}'".format(
                    self._hostname)
            )
            return False

        logger.info("  {} is down".format(self._hostname))
        return True

    def wait_for_host(self, timeout=60):
        logger.info("  waiting for {}...".format(self._hostname))
        end = datetime.now() + timedelta(seconds=timeout)
        while not self.is_up():
            time.sleep(0.25)
            if datetime.now() > end:
                logger.error(
                    "  could not ping '{}' within {} secs".format(
                        self._hostname, timeout)
                )
                return False
        if self._port:
            while True:
                try:
                    socket.create_connection(
                        (self._hostname, self._port), timeout=1)
                    break
                except OSError as ex:
                    logger.debug(
                        "  could not connect to '{}:{}' within {} secs: {}".format(
                            self._hostname, self._port, timeout, ex)
                    )
                time.sleep(0.25)
                if datetime.now() > end:
                    logger.error(
                        "  could not connect to '{}:{}' within {} secs: {}".format(
                            self._hostname, self._port, timeout, ex)
                    )
                    return False

        logger.info("  {} is up".format(self._hostname))
        return True


class Session(object):
    def __init__(self, ssh_client, session_name, yaml) -> None:
        self._session_name = session_name
        self._ssh_client = ssh_client  # type: SSHClient

        if "user" in yaml:
            self._user = yaml["user"]
        else:
            self._user = DEFAULT_USER

        if "host" in yaml:
            self._host = yaml["host"]
        else:
            self._host = DEFAULT_HOST

        if "command" in yaml:
            self._command = yaml["command"]
        else:
            raise Exception("No command in session section")

        if "wait_for_core" in yaml:
            self._wait_for_core = yaml["wait_for_core"]
        else:
            self._wait_for_core = True

        if "pre_condition" in yaml:
            self._pre_condition = yaml["pre_condition"]
        else:
            self._pre_condition = None

        if "prio" in yaml:
            self.prio = int(yaml["prio"])
        else:
            self.prio = 10

        if "locked" in yaml:
            self._locked = yaml["locked"]
        else:
            self._locked = False

    # for now it is not possible to detect if a session has started completely
    # (e.g. roslauch command is telling us that all nodes are up) find a way to detect this
    # as ros2 uses python as a launch system, it should be possible to detect this
    def start(self):
        logger.info("  session {}: start".format(self._session_name))
        
        if self._wait_for_core:
            logger.info("  session {}: waiting for roscore".format(
                self._session_name))
            # wait for roscore
            while not rosgraph.is_master_online():
                time.sleep(0.25)
                logger.debug("  session {}: waiting for roscore!".format(
                    self._session_name))

        if self._pre_condition:
            logger.info("  session {}: checking precondition: {}".format(
                self._session_name, self._pre_condition))
            # check for precondition
            while True:
                ret, _, _ = self._ssh_client.send_cmd(
                    'source /u/{}/setup/user.bashrc && {}'.format(self._user, self._pre_condition), True)
                if not ret:
                    break
                time.sleep(0.25)
                
            logger.info("  session {}: precondition fullfilled: {}".format(
                self._session_name, self._pre_condition))

        if self._ssh_client.has_session(session_name=self._session_name):
            logger.warning(
                "  session {}: already running".format(self._session_name))
        else:
            self._ssh_client.new_session(session_name=self._session_name)
            self._ssh_client.send_keys(self._session_name, self._command)

    def stop(self, force=False):
        logger.info("  session {}: stop".format(self._session_name))
        if self._ssh_client.has_session(session_name=self._session_name):
            if self._locked and not force:
                logger.warning(
                    "  session {}: is locked - skipping...".format(
                        self._session_name)

                )
                return
            self._ssh_client.stop_session(session_name=self._session_name)
        else:
            logger.warning(
                "  session {}: not running".format(self._session_name)

            )

    def restart(self):
        self.stop()
        self.start()

    def terminate(self):
        pass

    def dump(self):
        print("session_name{}:".format(self._session_name))
        print("\thost: {}".format(self._host))
        print("\tuser: {}".format(self._user))
        print("\tcommand: {}".format(self._command))
        print("\tpre_condition: {}".format(self._pre_condition))
        print("\tprio: {}".format(self.prio))
        print("\tlocked: {}".format(self._locked))


def wait_for_hosts(hosts, timeout=30):
    start = datetime.now()
    logger.info("==================================")
    logger.info("wait for hosts:")

    ret = True
    hosts_c = copy.deepcopy(hosts)

    # remove own host pc from list
    hosts_c.pop(socket.gethostname(), None)
    with ThreadPoolExecutor(max_workers=len(hosts_c)) as executor:
        futures = {executor.submit(
            hosts_c[key].wait_for_host, timeout): key for key in hosts_c}

        for f in concurrent.futures.as_completed(futures):
            ret = ret and f.result()
    if ret:
        logger.info("all hosts are up")
    else:
        logger.error("could not reach all hosts")

    logger.debug("waiting for hosts took {} secs".format(
        (datetime.now() - start).total_seconds()))
    return ret


def shutdown_system(hosts, timeout=60):
    start = datetime.now()
    logger.info("==================================")
    logger.info("shutting down hosts:")
    futures = []
    hosts_c = copy.deepcopy(hosts)
    hosts_c.pop(socket.gethostname(), None)
    with ThreadPoolExecutor(max_workers=len(hosts)) as executor:
        futures = {executor.submit(
            hosts_c[key].shutdown, timeout): key for key in hosts_c}

        for f in concurrent.futures.as_completed(futures):
            f.result()

    hosts[socket.gethostname()].shutdown(timeout=timeout)
    logger.debug("shutting down took {} secs".format(
        (datetime.now() - start).total_seconds()))


def order_sessions_by_key(sessions, key):
    ordered_array = sorted(sessions, key=operator.attrgetter(key))
    ordered_sessions = dict()
    for s in ordered_array:
        if not s.prio in ordered_sessions:
            ordered_sessions[s.prio] = []
        ordered_sessions[s.prio].append(s)
    # returns a dict of arrays with prio as key and array of session with the same key(prio) as value
    return ordered_sessions


def start_sessions(sessions):
    start = datetime.now()
    # create thread pool to execute
    for prio in sessions:
        start = datetime.now()
        logger.info("==================================")
        logger.info("start sessions with prio {}:".format(prio))
        with ThreadPoolExecutor(max_workers=len(sessions)) as executor:
            futures = {executor.submit(s.start): s for s in sessions[prio]}
            for f in concurrent.futures.as_completed(futures):
                f.result()
        logger.info("sessions with prio {} started in {} secs".format(
            prio, (datetime.now() - start).seconds))
        logger.info("done")
    logger.debug("starting sessions took {} secs".format(
        (datetime.now() - start).total_seconds()))


def stop_sessions(sessions, force=False):
    start = datetime.now()
    # create thread pool to execute
    for prio in reversed(sessions):
        start = datetime.now()
        logger.info("==================================")
        logger.info("stop sessions with prio {}:".format(prio))
        with ThreadPoolExecutor(max_workers=len(sessions)) as executor:
            futures = {executor.submit(s.stop, force): s for s in sessions[prio]}
            for f in concurrent.futures.as_completed(futures):
                f.result()
        logger.info("sessions with prio {} stopped in {} secs".format(
            prio, (datetime.now() - start).seconds))
        logger.info("done")
    logger.debug("stopping sessions took {} secs".format(
        (datetime.now() - start).total_seconds()))


if __name__ == "__main__":
    start = datetime.now()
    parser = argparse.ArgumentParser(description="robmuxinator")
    parser.add_argument(
        "command",
        choices=["start", "stop", "restart", "shutdown"],
        help="which command should be executed",
    )
    parser.add_argument(
        "-c", 
        "--config", 
        help="the path to the yaml config file", 
        default="/etc/ros/cob.yaml"
    )
    parser.add_argument(
        "-s",
        "--sessions",
        required=False,
        action="append",
        help="which sessions should be started/stopped",
    )
    parser.add_argument(
        "-f",
        "--force",
        required=False,
        action="store_true",
        help="close sessions even if they are locked",
    )
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    # parse arguments
    yaml_file = args.config
    command = args.command

    # load yaml file
    with open(yaml_file, "r") as fs:
        yaml_content = yaml.safe_load(fs)

    # check and get hosts
    hosts = dict()
    if "hosts" in yaml_content:
        yaml_hosts = yaml_content["hosts"]
        for key in yaml_hosts:
            if "port" in yaml_hosts[key]:
                port = yaml_hosts[key]["port"]
            else:
                port = DEFAULT_PORT

            if "check_nfs" in yaml_hosts[key]:
                check_nfs = yaml_hosts[key]["check_nfs"]
            else:
                check_nfs = True

            if yaml_hosts[key]["os"] == "linux":
                hosts[key] = LinuxHost(
                    key, yaml_hosts[key]["user"], port, check_nfs)
            elif yaml_hosts[key]["os"] == "windows":
                hosts[key] = WindowsHost(key, yaml_hosts[key]["user"], port)
            else:
                logger.error("unknown host os: {}".format(
                    yaml_hosts[key]["os"]))
                sys.exit(1)

    else:
        logger.error("{} does not contain key 'hosts'".format(yaml_file))
        sys.exit()

    timeout = None
    if "timeout" in yaml_content:
        timeout = yaml_content["timeout"]
    else:
        logger.error("{} does not contain key 'timeout'".format(yaml_file))
        sys.exit()

    # get sessions from yaml
    yaml_sessions = None
    if "sessions" in yaml_content:
        yaml_sessions = yaml_content["sessions"]
    else:
        logger.error("{} does not contain key 'sessions'".format(yaml_file))
        sys.exit()

    # init sessions
    sessions = []
    try:
        for key in yaml_sessions:
            host = DEFAULT_HOST
            user = DEFAULT_USER
            if "host" in yaml_sessions[key]:
                host = yaml_sessions[key]["host"]
            if "user" in yaml_sessions[key]:
                user = yaml_sessions[key]["user"]
            if args.sessions:
                if key in args.sessions:
                    sessions.append(
                        Session(SSHClient(user=user, host=host),
                                key, yaml_sessions[key])
                    )
            else:
                sessions.append(
                    Session(SSHClient(user=user, host=host),
                            key, yaml_sessions[key])
                )
    except Exception as e:
        logger.error(e)
        sys.exit()

    ordered_sessions = order_sessions_by_key(sessions, "prio")

    if command == "start":
        # wait for other hosts
        if len(hosts) > 1 and not wait_for_hosts(hosts, timeout):
            sys.exit()
        start_sessions(ordered_sessions)
        logger.info("starting took {} secs".format(
            (datetime.now() - start).total_seconds()))
    elif command == "stop":
        stop_sessions(ordered_sessions, args.force)
        logger.info("stopping took {} secs".format(
            (datetime.now() - start).total_seconds()))
    elif command == "restart":
        stop_sessions(ordered_sessions, args.force)
        start_sessions(ordered_sessions)
        logger.info("restart took {} secs".format(
            (datetime.now() - start).total_seconds()))
    elif command == "shutdown":
        stop_sessions(ordered_sessions, True)
        shutdown_system(hosts)
